<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Cube Shooter - WebGL Game</title>
		<style>
			body {
				margin: 0;
				overflow: hidden;
				background-color: #000;
				color: white;
				font-family: sans-serif;
			}
			canvas {
				display: block;
			}
			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.7);
				display: flex;
				justify-content: center;
				align-items: center;
				flex-direction: column;
				text-align: center;
				z-index: 5;
			}
			#instructions {
				width: 60%;
				cursor: pointer;
				background-color: rgba(50, 50, 50, 0.8);
				padding: 20px;
				border-radius: 10px;
				border: 1px solid #aaa;
			}
			#instructions p {
				font-size: 18px;
				line-height: 1.5;
			}
			#instructions strong {
				font-size: 24px;
				color: #ffeb3b;
			}

			#hud {
				position: absolute;
				top: 10px;
				left: 10px;
				background-color: rgba(0, 0, 0, 0.5);
				padding: 10px;
				border-radius: 5px;
				font-size: 16px;
				z-index: 2;
			}
			.hud-item {
				margin-bottom: 5px;
			}
			.hud-item strong {
				color: #ffeb3b;
			}
			#reloading-status {
				color: orange;
				font-weight: bold;
				display: none;
			}

			#crosshair {
				position: absolute;
				top: 50%;
				left: 50%;
				width: 4px;
				height: 4px;
				background-color: red;
				border-radius: 50%;
				transform: translate(-50%, -50%);
				pointer-events: none;
				display: none;
				z-index: 2;
			}

			.menu {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background-color: rgba(30, 30, 30, 0.95);
				padding: 30px;
				border-radius: 10px;
				border: 2px solid #ccc;
				text-align: center;
				display: none;
				z-index: 10;
				min-width: 250px;
			}
			.menu h2 {
				margin-top: 0;
				color: #ffeb3b;
			}
			.menu button {
				display: block;
				width: 100%;
				padding: 10px 20px;
				margin: 10px 0;
				font-size: 18px;
				cursor: pointer;
				background-color: #555;
				color: white;
				border: 1px solid #888;
				border-radius: 5px;
			}
			.menu button:hover:not(:disabled) {
				background-color: #777;
			}
			.menu button:disabled {
				background-color: #444;
				color: #888;
				cursor: not-allowed;
			}
			.menu p {
				margin-bottom: 15px;
			}

			#game-over-screen {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(100, 0, 0, 0.8);
				display: none;
				justify-content: center;
				align-items: center;
				flex-direction: column;
				text-align: center;
				z-index: 20;
				font-size: 36px;
				color: white;
			}
			#game-over-screen h1 {
				color: #ffdddd;
				margin-bottom: 20px;
			}
			#game-over-screen p {
				font-size: 24px;
				margin-bottom: 20px;
			}
			#game-over-screen button {
				padding: 15px 30px;
				font-size: 24px;
				cursor: pointer;
				background-color: #eee;
				color: #333;
				border: none;
				border-radius: 5px;
				margin-top: 20px;
			}
			#game-over-screen button:hover {
				background-color: #ccc;
			}
		</style>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
		<script src="https://unpkg.com/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
	</head>
	<body>
		<div id="blocker">
			<div id="instructions">
				<strong>Click to Play</strong>
				<p>
					WASD: Move<br />
					SPACE: Jump<br />
					HOLD MOUSE: Shoot<br />
					R: Reload<br />
					ESC: Pause / Resume / Close Shop<br />
					B: Open Shop (when paused)
				</p>
				<p style="font-size: 14px">
					Defeat the endless waves of red cubes!
				</p>
				<p style="font-size: 14px">Collect yellow coins!</p>
			</div>
		</div>

		<div id="hud">
			<div class="hud-item">
				<strong>Health:</strong> <span id="health">100</span>
			</div>
			<div class="hud-item">
				<strong>Ammo:</strong> <span id="ammo">30</span> /
				<span id="max-ammo">30</span>
			</div>
			<div class="hud-item">
				<strong>Coins:</strong> <span id="coins">0</span>
			</div>
			<div class="hud-item">
				<strong>Fire Rate:</strong>
				<span id="fire-rate">0.0</span> shots/sec
			</div>
			<div class="hud-item">
				<strong>Enemies:</strong> <span id="enemies-left">0</span>
			</div>
			<div class="hud-item">
				<strong>Wave:</strong> <span id="wave-number">0</span>
			</div>
			<div class="hud-item" id="reloading-status">Reloading...</div>
		</div>

		<div id="crosshair">+</div>

		<div id="pause-menu" class="menu">
			<h2>Paused</h2>
			<button id="resume-button">Resume</button>
			<button id="shop-button">Shop</button>
			<button id="restart-button-pause">Restart Game</button>
		</div>

		<div id="shop-menu" class="menu">
			<h2>Shop</h2>
			<p>Coins: <span id="shop-coins">0</span></p>
			<button id="upgrade-max-ammo">
				Upgrade Clip Size (+10) - Cost: 50
			</button>
			<button id="upgrade-fire-rate">
				Upgrade Fire Rate (+20%) - Cost: 75
			</button>
			<button id="buy-health">Buy Health (+25) - Cost: 30</button>
			<button id="buy-ammo">Refill Clip - Cost: 20</button>
			<hr style="border-color: #555; margin: 15px 0" />
			<button id="close-shop-button">Close Shop / Back to Pause</button>
		</div>

		<div id="game-over-screen">
			<h1>Game Over!</h1>
			<p>Final Wave: <span id="final-wave">0</span></p>
			<button id="restart-button-gameover">Restart Game</button>
		</div>

		<script>
			let scene, camera, renderer, controls, clock;
			let raycaster;

			let player = {
				collider: new THREE.Box3(),
				radius: 0.4,
				height: 1.8,
				speed: 8.0,
				jumpHeight: 1,
				health: 100,
				maxHealth: 100,
				ammo: 30,
				clipSize: 30,
				maxAmmoStorage: 90,
				coins: 0,
				damage: 10,
				fireRate: 0.2,
				lastShotTime: 0,
				kills: 0,
				isReloading: false,
				reloadTime: 1.5,
				reloadTimer: 0,
			};
			const MIN_FIRE_RATE = 0.05;

			let ground;
			let enemies = [];
			let coinsOnGround = [];
			let projectiles = [];
			let collidableObjects = [];
			const enemySpawnLocations = [
				new THREE.Vector3(-25, 0.5, -25),
				new THREE.Vector3(25, 0.5, -25),
				new THREE.Vector3(-25, 0.5, 25),
				new THREE.Vector3(25, 0.5, 25),
				new THREE.Vector3(0, 0.5, -30),
				new THREE.Vector3(0, 0.5, 30),
				new THREE.Vector3(-30, 0.5, 0),
				new THREE.Vector3(30, 0.5, 0),
			];
			const baseEnemyMaterial = new THREE.MeshStandardMaterial({
				color: 0xff0000,
			});

			const projectileSpeed = 90.0;
			const projectileMaxDist = 120;
			const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
			const projectileMaterial = new THREE.MeshBasicMaterial({
				color: 0xffff00,
			});

			let waveNumber = 0,
				timeSinceLastSpawn = 0;
			let spawnInterval = 5.0;
			let initialEnemyCount = 3,
				enemiesPerWave = initialEnemyCount;
			const spawnIncreaseFactor = 0.6;

			let moveForward = false,
				moveBackward = false,
				moveLeft = false,
				moveRight = false;
			let canJump = false;
			let velocity = new THREE.Vector3();
			let direction = new THREE.Vector3();
			const gravity = 0.05;
			const jumpVelocity = 1.5;

			let isShooting = false;

			let isPaused = false,
				isShopOpen = false,
				isGameOver = false,
				gameStarted = false;

			const blocker = document.getElementById("blocker");
			const instructions = document.getElementById("instructions");
			const hudHealth = document.getElementById("health");
			const hudAmmo = document.getElementById("ammo");
			const hudMaxAmmo = document.getElementById("max-ammo");
			const hudCoins = document.getElementById("coins");
			const hudFireRate = document.getElementById("fire-rate");
			const hudEnemiesLeft = document.getElementById("enemies-left");
			const hudWaveNumber = document.getElementById("wave-number");
			const hudReloadingStatus =
				document.getElementById("reloading-status");
			const crosshair = document.getElementById("crosshair");
			const pauseMenu = document.getElementById("pause-menu");
			const shopMenu = document.getElementById("shop-menu");
			const shopCoins = document.getElementById("shop-coins");
			const gameOverScreen = document.getElementById("game-over-screen");
			const finalWaveDisplay = document.getElementById("final-wave");
			const upgradeMaxAmmoButton =
				document.getElementById("upgrade-max-ammo");
			const upgradeFireRateButton =
				document.getElementById("upgrade-fire-rate");
			const buyHealthButton = document.getElementById("buy-health");
			const buyAmmoButton = document.getElementById("buy-ammo");

			const upgradeMaxAmmoCost = 50;
			const upgradeFireRateCost = 75;
			const buyHealthCost = 30;
			const buyAmmoCost = 20;

			init();
			animate();

			function init() {
				clock = new THREE.Clock();
				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x87ceeb);
				scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

				camera = new THREE.PerspectiveCamera(
					75,
					window.innerWidth / window.innerHeight,
					0.1,
					1000
				);
				camera.position.y = player.height;

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMap.enabled = true;
				document.body.appendChild(renderer.domElement);

				const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
				scene.add(ambientLight);
				const directionalLight = new THREE.DirectionalLight(
					0xffffff,
					0.8
				);
				directionalLight.position.set(15, 20, 10);
				directionalLight.castShadow = true;
				directionalLight.shadow.mapSize.width = 1024;
				directionalLight.shadow.mapSize.height = 1024;
				directionalLight.shadow.camera.near = 0.5;
				directionalLight.shadow.camera.far = 60;
				directionalLight.shadow.camera.left = -35;
				directionalLight.shadow.camera.right = 35;
				directionalLight.shadow.camera.top = 35;
				directionalLight.shadow.camera.bottom = -35;
				scene.add(directionalLight);

				controls = new THREE.PointerLockControls(camera, document.body);
				blocker.addEventListener("click", () => {
					if (!gameStarted || !controls.isLocked) controls.lock();
				});
				controls.addEventListener("lock", onLock);
				controls.addEventListener("unlock", onUnlock);
				scene.add(controls.getObject());

				raycaster = new THREE.Raycaster(
					new THREE.Vector3(),
					new THREE.Vector3(0, -1, 0),
					0,
					player.height * 0.6
				);

				document.addEventListener("keydown", onKeyDown);
				document.addEventListener("keyup", onKeyUp);
				document.addEventListener("mousedown", onMouseDown);
				document.addEventListener("mouseup", onMouseUp);

				window.addEventListener("resize", onWindowResize);
				document
					.getElementById("resume-button")
					.addEventListener("click", () => controls.lock());
				document
					.getElementById("shop-button")
					.addEventListener("click", openShop);
				document
					.getElementById("close-shop-button")
					.addEventListener("click", closeShop);
				document
					.getElementById("restart-button-pause")
					.addEventListener("click", restartGame);
				document
					.getElementById("restart-button-gameover")
					.addEventListener("click", restartGame);
				upgradeMaxAmmoButton.addEventListener("click", () =>
					purchaseUpgrade("clipSize")
				);
				upgradeFireRateButton.addEventListener("click", () =>
					purchaseUpgrade("fireRate")
				);
				buyHealthButton.addEventListener("click", () =>
					purchaseUpgrade("health")
				);
				buyAmmoButton.addEventListener("click", () =>
					purchaseUpgrade("ammo")
				);

				createLevel();
				spawnGroundCoins(15);
				resetGameVariables();
				updateHUD();
				updateShopUI();
			}

			function onLock() {
				if (!isGameOver) {
					blocker.style.display = "none";
					instructions.style.display = "none";
					isPaused = false;
					pauseMenu.style.display = "none";
					shopMenu.style.display = "none";
					isShopOpen = false;
					crosshair.style.display = "block";
					gameStarted = true;
				}
			}

			function onUnlock() {
				if (!isGameOver) {
					blocker.style.display = "flex";
					isPaused = true;
					if (!isShopOpen) pauseMenu.style.display = "block";
					else shopMenu.style.display = "block";
					crosshair.style.display = "none";
					isShooting = false;
				}
			}

			function resetGameVariables() {
				player.health = player.maxHealth;
				player.ammo = player.clipSize;
				player.coins = 0;
				player.kills = 0;
				player.lastShotTime = 0;
				player.isReloading = false;
				player.reloadTimer = 0;

				waveNumber = 0;
				timeSinceLastSpawn = spawnInterval;
				enemiesPerWave = initialEnemyCount;

				enemies.forEach((e) => {
					if (e.mesh) scene.remove(e.mesh);
				});
				enemies = [];
				coinsOnGround.forEach((c) => scene.remove(c));
				coinsOnGround = [];
				projectiles.forEach((p) => scene.remove(p));
				projectiles = [];

				velocity.set(0, 0, 0);
				moveForward = moveBackward = moveLeft = moveRight = false;
				canJump = false;
				isPaused = false;
				isShopOpen = false;
				isGameOver = false;
				isShooting = false;

				const playerObject = controls.getObject();
				playerObject.position.set(0, player.height, 5);
				if (controls.velocity) controls.velocity.set(0, 0, 0);
			}

			function createLevel() {
				collidableObjects = [];

				const groundGeometry = new THREE.PlaneGeometry(100, 100);
				const groundMaterial = new THREE.MeshStandardMaterial({
					color: 0x556b2f,
					side: THREE.DoubleSide,
				});
				ground = new THREE.Mesh(groundGeometry, groundMaterial);
				ground.rotation.x = -Math.PI / 2;
				ground.receiveShadow = true;
				scene.add(ground);

				const wallHeight = 5,
					wallThickness = 1;
				const wallMaterial = new THREE.MeshStandardMaterial({
					color: 0x777777,
				});
				const wallPositions = [
					{ x: 0, z: -50.5, w: 101, d: wallThickness },
					{ x: 0, z: 50.5, w: 101, d: wallThickness },
					{ x: -50.5, z: 0, w: wallThickness, d: 101 },
					{ x: 50.5, z: 0, w: wallThickness, d: 101 },
				];
				wallPositions.forEach((pos) => {
					const wallGeom = new THREE.BoxGeometry(
						pos.w,
						wallHeight,
						pos.d
					);
					const wall = new THREE.Mesh(wallGeom, wallMaterial);
					wall.position.set(pos.x, wallHeight / 2, pos.z);
					wall.receiveShadow = true;
					wall.castShadow = true;
					scene.add(wall);
					collidableObjects.push(wall);
				});

				const boxMaterial = new THREE.MeshStandardMaterial({
					color: 0xaaaaaa,
				});
				const rampMaterial = new THREE.MeshStandardMaterial({
					color: 0x999977,
				});

				const boxGeom = new THREE.BoxGeometry(3, 3, 3);
				const box1 = new THREE.Mesh(boxGeom, boxMaterial);
				box1.position.set(-10, 1.5, -10);
				box1.castShadow = true;
				box1.receiveShadow = true;
				scene.add(box1);
				collidableObjects.push(box1);

				const box2 = new THREE.Mesh(
					new THREE.BoxGeometry(5, 2, 5),
					boxMaterial
				);
				box2.position.set(15, 1, 15);
				box2.castShadow = true;
				box2.receiveShadow = true;
				scene.add(box2);
				collidableObjects.push(box2);

				const rampGeom = new THREE.BoxGeometry(4, 0.5, 10);
				const ramp = new THREE.Mesh(rampGeom, rampMaterial);
				ramp.position.set(0, 1, 15);
				ramp.rotation.x = -Math.PI / 8;
				ramp.castShadow = true;
				ramp.receiveShadow = true;
				scene.add(ramp);
				collidableObjects.push(ramp);

				const platGeom = new THREE.BoxGeometry(8, 1, 8);
				const platform = new THREE.Mesh(platGeom, boxMaterial);
				platform.position.set(-15, 4, 10);
				platform.castShadow = true;
				platform.receiveShadow = true;
				scene.add(platform);
				collidableObjects.push(platform);

				const cylGeom = new THREE.CylinderGeometry(2, 2, 6, 16);
				const cylinder = new THREE.Mesh(cylGeom, boxMaterial);
				cylinder.position.set(10, 3, -15);
				cylinder.castShadow = true;
				cylinder.receiveShadow = true;
				scene.add(cylinder);
				collidableObjects.push(cylinder);

				collidableObjects.forEach((obj) => {
					obj.geometry.computeBoundingBox();
					obj.userData.bbox = new THREE.Box3();
					obj.userData.bbox.setFromObject(obj);
				});
			}

			function spawnGroundCoins(count) {
				const coinGeometry = new THREE.CylinderGeometry(
					0.6,
					0.6,
					0.1,
					16
				);
				const coinMaterial = new THREE.MeshStandardMaterial({
					color: 0xd4af37,
					emissive: 0xaa8800,
				});
				const spawnArea = 45;

				for (let i = 0; i < count; i++) {
					const coinMesh = new THREE.Mesh(coinGeometry, coinMaterial);
					coinMesh.castShadow = true;
					let coinPos = new THREE.Vector3(
						(Math.random() - 0.5) * spawnArea * 2,
						0.3,
						(Math.random() - 0.5) * spawnArea * 2
					);
					coinMesh.position.copy(coinPos);
					coinMesh.rotation.x = Math.PI / 2;
					coinMesh.userData = {
						value: 5 + Math.floor(Math.random() * 6),
					};
					coinsOnGround.push(coinMesh);
					scene.add(coinMesh);
				}
			}

			function spawnEnemies(count) {
				const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
				for (let i = 0; i < count; i++) {
					const enemyMaterialInstance = baseEnemyMaterial.clone();
					const enemyMesh = new THREE.Mesh(
						enemyGeometry,
						enemyMaterialInstance
					);
					enemyMesh.castShadow = true;
					enemyMesh.receiveShadow = true;

					let spawnPos,
						tooClose,
						attempts = 0;
					const minSpawnDist = 5,
						minPlayerDist = 10;
					do {
						tooClose = false;
						attempts++;
						if (
							enemySpawnLocations.length > 0 &&
							Math.random() < 0.8
						) {
							spawnPos =
								enemySpawnLocations[
									Math.floor(
										Math.random() *
											enemySpawnLocations.length
									)
								].clone();
						} else {
							spawnPos = new THREE.Vector3(
								(Math.random() - 0.5) * 80,
								0.5,
								(Math.random() - 0.5) * 80
							);
						}
						spawnPos.y = 0.5;

						if (
							camera &&
							camera.position.distanceTo(spawnPos) < minPlayerDist
						) {
							tooClose = true;
							continue;
						}
						for (let j = 0; j < enemies.length; j++) {
							if (
								enemies[j] &&
								enemies[j].mesh &&
								enemies[j].mesh.position.distanceTo(spawnPos) <
									minSpawnDist
							) {
								tooClose = true;
								break;
							}
						}
					} while (tooClose && attempts < 20);

					enemyMesh.position.copy(spawnPos);
					enemyMesh.userData.bbox = new THREE.Box3();
					enemyMesh.userData.bbox.setFromObject(enemyMesh);

					const enemyData = {
						mesh: enemyMesh,
						health: 1,
						speed: 0.06 + Math.random() * 0.03 + waveNumber * 0.003,
						damage: 5 + Math.floor(waveNumber / 3),
						attackCooldown: Math.max(0.5, 1.5 - waveNumber * 0.02),
						lastAttackTime: 0,
						reward: 10 + Math.floor(Math.random() * 6) + waveNumber,
					};
					enemyMesh.userData = {
						...enemyMesh.userData,
						...enemyData,
					};

					enemies.push(enemyData);
					scene.add(enemyMesh);
				}
				updateHUD();
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function onKeyDown(event) {
				switch (event.code) {
					case "KeyW":
						moveForward = true;
						break;
					case "KeyA":
						moveLeft = true;
						break;
					case "KeyS":
						moveBackward = true;
						break;
					case "KeyD":
						moveRight = true;
						break;
					case "Space":
						if (canJump && !player.isReloading)
							velocity.y = jumpVelocity;
						canJump = false;
						break;
					case "KeyR":
						if (
							!player.isReloading &&
							player.ammo < player.clipSize
						)
							startReload();
						break;
					case "Escape":
						if (controls.isLocked) controls.unlock();
						else {
							if (isShopOpen) closeShop();
							else if (isPaused && !isGameOver) controls.lock();
						}
						break;
					case "KeyB":
						if (isPaused && !isShopOpen && !isGameOver) openShop();
						break;
				}
			}

			function onKeyUp(event) {
				switch (event.code) {
					case "KeyW":
						moveForward = false;
						break;
					case "KeyA":
						moveLeft = false;
						break;
					case "KeyS":
						moveBackward = false;
						break;
					case "KeyD":
						moveRight = false;
						break;
				}
			}

			function onMouseDown(event) {
				if (event.button === 0 && controls.isLocked && !isGameOver) {
					isShooting = true;
				}
			}

			function onMouseUp(event) {
				if (event.button === 0) {
					isShooting = false;
				}
			}

			function startReload() {
				if (player.isReloading || player.ammo === player.clipSize)
					return;
				player.isReloading = true;
				player.reloadTimer = 0;
				hudReloadingStatus.style.display = "block";
			}

			function finishReload() {
				player.ammo = player.clipSize;
				player.isReloading = false;
				hudReloadingStatus.style.display = "none";
				updateHUD();
			}

			function shoot() {
				if (
					!controls.isLocked ||
					isGameOver ||
					player.isReloading ||
					player.ammo <= 0
				)
					return;

				player.ammo--;
				player.lastShotTime = clock.getElapsedTime();

				const projectile = new THREE.Mesh(
					projectileGeometry,
					projectileMaterial
				);
				const cameraPosition = new THREE.Vector3();
				const cameraDirection = new THREE.Vector3();
				camera.getWorldPosition(cameraPosition);
				camera.getWorldDirection(cameraDirection);
				projectile.position
					.copy(cameraPosition)
					.add(cameraDirection.multiplyScalar(0.5));
				const velocity = cameraDirection
					.clone()
					.multiplyScalar(projectileSpeed);
				projectile.userData = {
					velocity: velocity,
					distanceTraveled: 0,
				};
				scene.add(projectile);
				projectiles.push(projectile);

				updateHUD();
				if (player.ammo === 0) startReload();
			}

			function updateProjectiles(delta) {
				for (let i = projectiles.length - 1; i >= 0; i--) {
					const proj = projectiles[i];
					if (!proj || !proj.userData || !proj.userData.velocity)
						continue;

					const moveVector = proj.userData.velocity
						.clone()
						.multiplyScalar(delta);
					proj.position.add(moveVector);
					proj.userData.distanceTraveled += moveVector.length();

					let hit = false;
					proj.userData.bbox = new THREE.Box3().setFromObject(proj);

					for (let j = enemies.length - 1; j >= 0; j--) {
						const enemy = enemies[j];
						if (!enemy || !enemy.mesh || !enemy.mesh.userData.bbox)
							continue;

						if (
							proj.userData.bbox.intersectsBox(
								enemy.mesh.userData.bbox
							)
						) {
							hit = true;
							enemy.health = 0;

							const knockbackForce = new THREE.Vector3()
								.subVectors(enemy.mesh.position, proj.position)
								.normalize()
								.multiplyScalar(0.5);
							enemy.mesh.position.add(knockbackForce);

							enemy.mesh.material.color.set(0xffffff);
							const currentEnemyMesh = enemy.mesh;
							setTimeout(() => {
								if (
									currentEnemyMesh &&
									currentEnemyMesh.material
								)
									currentEnemyMesh.material.color.set(
										0xff0000
									);
							}, 100);

							scene.remove(enemy.mesh);
							enemies.splice(j, 1);
							player.coins += enemy.reward;
							player.kills++;
							updateHUD();
							updateShopUI();
							break;
						}
					}

					if (
						hit ||
						proj.userData.distanceTraveled > projectileMaxDist
					) {
						scene.remove(proj);
						projectiles.splice(i, 1);
					}
				}
			}

			function updateEnemies(delta) {
				if (isGameOver) return;
				const currentTime = clock.getElapsedTime();
				const playerPosition = controls.getObject().position;

				for (let i = enemies.length - 1; i >= 0; i--) {
					const enemy = enemies[i];
					if (!enemy || !enemy.mesh) continue;

					const enemyMesh = enemy.mesh;
					enemyMesh.userData.bbox.setFromObject(enemyMesh);

					const directionToPlayer = new THREE.Vector3().subVectors(
						playerPosition,
						enemyMesh.position
					);
					directionToPlayer.y = 0;
					const distanceToPlayer = directionToPlayer.length();
					directionToPlayer.normalize();

					const moveStep = directionToPlayer.multiplyScalar(
						enemy.speed * delta * 60
					);
					enemyMesh.position.add(moveStep);

					enemyMesh.lookAt(
						playerPosition.x,
						enemyMesh.position.y,
						playerPosition.z
					);

					const attackRange = 1.5;
					if (
						distanceToPlayer < attackRange &&
						currentTime >
							enemy.lastAttackTime + enemy.attackCooldown
					) {
						player.health -= enemy.damage;
						enemy.lastAttackTime = currentTime;
						updateHUD();
						document.body.style.backgroundColor = "darkred";
						setTimeout(() => {
							if (!isGameOver)
								document.body.style.backgroundColor = "#000";
						}, 100);
						if (player.health <= 0) {
							endGame(false);
							return;
						}
					}
				}
			}

			function checkCollision(playerCollider, movementVector) {
				let collisionDetected = { x: false, z: false, y: false };
				const sweptPlayerCollider = playerCollider.clone();
				sweptPlayerCollider.translate(movementVector);

				for (const obj of collidableObjects) {
					if (
						obj.userData.bbox &&
						sweptPlayerCollider.intersectsBox(obj.userData.bbox)
					) {
						const tempColliderX = playerCollider.clone();
						tempColliderX.translate(
							new THREE.Vector3(movementVector.x, 0, 0)
						);
						if (tempColliderX.intersectsBox(obj.userData.bbox))
							collisionDetected.x = true;

						const tempColliderZ = playerCollider.clone();
						tempColliderZ.translate(
							new THREE.Vector3(0, 0, movementVector.z)
						);
						if (tempColliderZ.intersectsBox(obj.userData.bbox))
							collisionDetected.z = true;

						const tempColliderY = playerCollider.clone();
						tempColliderY.translate(
							new THREE.Vector3(0, movementVector.y, 0)
						);
						if (tempColliderY.intersectsBox(obj.userData.bbox))
							collisionDetected.y = true;
					}
				}
				return collisionDetected;
			}

			function updatePlayer(delta) {
				if (isGameOver) return;

				if (player.isReloading) {
					player.reloadTimer += delta;
					if (player.reloadTimer >= player.reloadTime) {
						finishReload();
					}
				}

				const playerObject = controls.getObject();

				raycaster.ray.origin.copy(playerObject.position);
				raycaster.ray.origin.y -= player.height * 0.4;
				const groundIntersections = raycaster.intersectObject(ground);
				const onGround =
					groundIntersections.length > 0 &&
					groundIntersections[0].distance < player.height * 0.6;

				velocity.x -= velocity.x * 10.0 * delta;
				velocity.z -= velocity.z * 10.0 * delta;
				if (!onGround) velocity.y -= gravity * delta * 60;
				else {
					if (velocity.y < 0) velocity.y = 0;
					canJump = true;
				}

				direction.z = Number(moveForward) - Number(moveBackward);
				direction.x = Number(moveLeft) - Number(moveRight);
				direction.normalize();

				const currentSpeed =
					player.speed * (player.isReloading ? 0.3 : 1);
				const forwardVector = new THREE.Vector3();
				playerObject.getWorldDirection(forwardVector);
				const rightVector = new THREE.Vector3();
				rightVector.copy(forwardVector).cross(playerObject.up).negate();

				const worldMoveX =
					(rightVector.x * direction.x +
						forwardVector.x * direction.z) *
					currentSpeed *
					delta;
				const worldMoveZ =
					(rightVector.z * direction.x +
						forwardVector.z * direction.z) *
					currentSpeed *
					delta;

				const playerCenter = playerObject.position.clone();
				player.collider.setFromCenterAndSize(
					playerCenter.add(
						new THREE.Vector3(
							0,
							-player.height / 2 + player.radius * 1.5,
							0
						)
					),
					new THREE.Vector3(
						player.radius * 2,
						player.height - player.radius * 2,
						player.radius * 2
					)
				);

				const totalMovement = new THREE.Vector3(
					worldMoveX,
					velocity.y * delta,
					worldMoveZ
				);
				const collision = checkCollision(
					player.collider,
					totalMovement
				);

				if (!collision.x) playerObject.position.x += totalMovement.x;
				if (!collision.z) playerObject.position.z += totalMovement.z;
				if (!collision.y) {
					playerObject.position.y += totalMovement.y;
					camera.position.y += totalMovement.y * 3;
				} else {
					if (velocity.y < 0) {
						velocity.y = 0;
						canJump = true;
					} else if (velocity.y > 0) {
						velocity.y = 0;
					}
				}

				const groundYThreshold = 0.1;
				if (playerObject.position.y < groundYThreshold) {
					velocity.y = 0;
					playerObject.position.y = groundYThreshold;
					canJump = true;
				}

				const playerPos = playerObject.position;
				const pickupRadiusSq = 2.0 * 2.0;
				for (let i = coinsOnGround.length - 1; i >= 0; i--) {
					const coin = coinsOnGround[i];
					if (coin && coin.position && playerPos) {
						if (
							playerPos.distanceToSquared(coin.position) <
							pickupRadiusSq
						) {
							player.coins += coin.userData.value;
							scene.remove(coin);
							coinsOnGround.splice(i, 1);
							updateHUD();
							updateShopUI();
						}
					}
				}
			}

			function updateHUD() {
				hudHealth.textContent = Math.max(0, Math.round(player.health));
				hudAmmo.textContent = player.ammo;
				hudMaxAmmo.textContent = player.clipSize;
				hudCoins.textContent = player.coins;
				const shotsPerSecond = (1 / player.fireRate).toFixed(1);
				hudFireRate.textContent = shotsPerSecond;
				hudEnemiesLeft.textContent = enemies.length;
				hudWaveNumber.textContent = waveNumber;
				hudReloadingStatus.style.display = player.isReloading
					? "block"
					: "none";
			}

			function updateShopUI() {
				shopCoins.textContent = player.coins;
				upgradeMaxAmmoButton.textContent = `Upgrade Clip Size (+10) - Cost: ${upgradeMaxAmmoCost}`;
				upgradeMaxAmmoButton.disabled =
					player.coins < upgradeMaxAmmoCost;

				const currentSPS = (1 / player.fireRate).toFixed(1);
				const nextFireRate = Math.max(
					MIN_FIRE_RATE,
					player.fireRate * 0.8
				);
				const nextSPS = (1 / nextFireRate).toFixed(1);
				upgradeFireRateButton.textContent = `Upgrade Fire Rate (${currentSPS} -> ${nextSPS} shots/sec) - Cost: ${upgradeFireRateCost}`;
				upgradeFireRateButton.disabled =
					player.coins < upgradeFireRateCost ||
					player.fireRate <= MIN_FIRE_RATE;

				buyHealthButton.textContent = `Buy Health (+25) - Cost: ${buyHealthCost}`;
				buyHealthButton.disabled =
					player.coins < buyHealthCost ||
					player.health >= player.maxHealth;
				buyAmmoButton.textContent = `Refill Clip - Cost: ${buyAmmoCost}`;
				buyAmmoButton.disabled =
					player.coins < buyAmmoCost ||
					player.ammo >= player.clipSize ||
					player.isReloading;
			}

			function openShop() {
				if (isPaused && !isGameOver) {
					isShopOpen = true;
					pauseMenu.style.display = "none";
					updateShopUI();
					shopMenu.style.display = "block";
				}
			}

			function closeShop() {
				isShopOpen = false;
				shopMenu.style.display = "none";
				if (isPaused && !isGameOver) {
					pauseMenu.style.display = "block";
				}
			}

			function purchaseUpgrade(type) {
				if (player.isReloading) return;

				let cost = 0;
				let purchased = false;

				switch (type) {
					case "clipSize":
						cost = upgradeMaxAmmoCost;
						if (player.coins >= cost) {
							player.clipSize += 10;
							player.ammo = player.clipSize;
							purchased = true;
						}
						break;
					case "fireRate":
						cost = upgradeFireRateCost;
						if (
							player.coins >= cost &&
							player.fireRate > MIN_FIRE_RATE
						) {
							player.fireRate = Math.max(
								MIN_FIRE_RATE,
								player.fireRate * 0.8
							);
							purchased = true;
						}
						break;
					case "health":
						cost = buyHealthCost;
						if (
							player.coins >= cost &&
							player.health < player.maxHealth
						) {
							player.health = Math.min(
								player.maxHealth,
								player.health + 25
							);
							purchased = true;
						}
						break;
					case "ammo":
						cost = buyAmmoCost;
						if (
							player.coins >= cost &&
							player.ammo < player.clipSize
						) {
							player.ammo = player.clipSize;
							purchased = true;
						}
						break;
				}

				if (purchased) {
					player.coins -= cost;
					updateHUD();
					updateShopUI();
				}
			}

			function endGame(won = false) {
				isGameOver = true;
				controls.unlock();
				isShooting = false;
				blocker.style.display = "none";
				pauseMenu.style.display = "none";
				shopMenu.style.display = "none";
				crosshair.style.display = "none";
				hudReloadingStatus.style.display = "none";

				finalWaveDisplay.textContent = waveNumber;
				gameOverScreen.style.display = "flex";

				if (won) {
					gameOverScreen.querySelector("h1").textContent =
						"You Survived!";
				} else {
					gameOverScreen.querySelector("h1").textContent =
						"Game Over!";
					player.health = 0;
					updateHUD();
				}
			}

			function restartGame() {
				resetGameVariables();
				spawnGroundCoins(15);

				gameOverScreen.style.display = "none";
				pauseMenu.style.display = "none";
				shopMenu.style.display = "none";
				crosshair.style.display = "none";
				blocker.style.display = "flex";
				instructions.style.display = "";
				gameStarted = false;

				updateHUD();
				updateShopUI();
			}

			function animate() {
				requestAnimationFrame(animate);
				const delta = clock.getDelta();
				const elapsedTime = clock.getElapsedTime();

				if (!isPaused && !isGameOver && controls.isLocked) {
					if (isShooting && !player.isReloading && player.ammo > 0) {
						if (
							elapsedTime >=
							player.lastShotTime + player.fireRate
						) {
							shoot();
						}
					} else if (
						isShooting &&
						!player.isReloading &&
						player.ammo <= 0
					) {
						startReload();
					}

					updatePlayer(delta);
					updateEnemies(delta);
					updateProjectiles(delta);

					timeSinceLastSpawn += delta;
					if (timeSinceLastSpawn >= spawnInterval) {
						timeSinceLastSpawn = 0;
						waveNumber++;
						enemiesPerWave = Math.floor(
							initialEnemyCount + waveNumber * spawnIncreaseFactor
						);
						spawnEnemies(enemiesPerWave);
						if (waveNumber % 3 === 0)
							spawnGroundCoins(5 + waveNumber);
						updateHUD();
					}
				} else if (isPaused && !isGameOver) {
				}

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
